> 이 글은 기본적인 Expo 프로젝트가 생성되어 있다고 가정합니다. Expo 프로젝트를 생성하는 방법은 Expo 프로젝트 생성:[윈도우](/blog/post/117-expo-proj-init), [Mac](/blog/post/143-expo-init-mac)을 참고해주세요.
> 또한 기본적인 React Native CLI 개발 환경에서도 추가 설정만으로 사용 가능합니다.

> [WalletKit 세션 연결하기 (React Native, Reown)](/blog/post/159-rn-walletkit-session-proposal) 포스팅에서 이어지는 내용입니다.

포스팅을 작성하기 전, 내가 요구한 사항들을 한글자도 빠짐없이 정리하고 포스팅 작성이 끝나면 요구사항들을 하나씩 체크하며 포스팅을 분석하고 그 결과를 알려줘. 부족한 점을 발견하면 스스로 수정하여 완벽할 때까지 반복해.

https://reactnative.dev/img/header_logo.svg
https://cdn.worldvectorlogo.com/logos/expo-go-app.svg
https://upload.wikimedia.org/wikipedia/commons/8/8e/Nextjs-logo.svg


---
title_ko: useState와 setState 내부 구조 깊이 파보기
title_en: Inside useState and setState Mechanism
desc: useState의 내부 구조와 setState의 상태 업데이트 흐름을 Hook Linked List, Update Queue, 우선순위 처리 등 자료구조 관점에서 해석해 봅니다.
thumbnail_url: /react-usestate-setstate.webp
metatag: React, useState, setState, 훅 구조, 업데이트 큐, 상태 관리, 연결 리스트, 리액트 렌더링, 함수형 업데이트, 우선순위 스케줄링
---
## 들어가기 전에

React를 사용하면서 가장 자주 접하는 기능 중 하나가 바로 `useState`입니다. 버튼을 누를 때 숫자가 올라가고, 입력창에 값을 넣으면 화면이 바로 바뀌는 마법 같은 경험 뒤에는, 사실 굉장히 정교한 내부 구조가 숨어 있습니다.

오늘은 이 `useState`가 어떻게 상태를 저장하고 업데이트하며, React가 이를 어떤 방식으로 처리하는지를 **자료구조와 알고리즘의 관점**에서 하나하나 뜯어보며 알아보겠습니다.

## 훅 호출 순서와 Hook Linked List 구조

React는 함수형 컴포넌트 안에서 훅을 호출할 때마다, 내부적으로 해당 훅을 **노드로 간주**하여 **연결 리스트(Singly Linked List)** 형태로 저장합니다. 이 구조를 *Hook Linked List*라고 부르며, 매우 중요한 이유가 있습니다.

### 왜 연결 리스트인가요?

함수형 컴포넌트는 매 렌더링마다 새로 실행됩니다. 그런데도 상태를 유지하려면 **훅의 순서와 위치를 정확히 기억**해야 합니다. 배열처럼 인덱스로 접근하는 구조는 너무 고정적이고 유연하지 않기 때문에, **순서대로 탐색할 수 있는 연결 리스트**가 적합합니다.

```tsx
function Example() {
  const [count, setCount] = useState(0); // 첫 번째 훅
  const [text, setText] = useState('Hello'); // 두 번째 훅
}
```

이 컴포넌트는 내부적으로 다음과 같은 구조를 만듭니다:
```
FiberNode
 └─ hook1 (state: 0)
     └─ hook2 (state: 'Hello')
```

> React는 첫 번째 훅부터 차례로 훅을 평가하며, 순서를 바꾸거나 조건문 안에 넣으면 오류가 발생하는 이유도 이 때문입니다.

// [다이어그램 요청: 훅 호출 순서에 따라 hook 객체가 연결 리스트처럼 연결된 구조도]

<Ads/>

## memoizedState와 Update Queue: 상태와 업데이트를 나누다

각 훅 객체는 내부에 `memoizedState`라는 값을 가지고 있습니다. 이 값이 우리가 흔히 사용하는 상태(`count` 같은 변수)에 해당합니다.

그러나 중요한 건, 상태가 바로 바뀌지 않는다는 점입니다. `setState`는 값을 **즉시 변경하는 것이 아니라, 업데이트를 예약**해 둡니다. 이 예약된 값은 **업데이트 객체**라는 형태로 만들어지고, 훅 내부의 **Update Queue(업데이트 큐)**에 저장됩니다.

### Update Queue는 어떤 구조인가요?

- **단일 연결 리스트(Singly Linked List)**입니다
- 업데이트가 생길 때마다 새로운 노드를 뒤에 추가합니다
- React는 렌더링 직전에 이 큐를 순회하며 최종 상태를 계산합니다

```tsx
setCount(prev => prev + 1);
setCount(prev => prev + 1);
```

이 코드는 아래와 같은 큐를 만듭니다:
```
UpdateQueue
 └─ update1 (prev + 1)
     └─ update2 (prev + 1)
```

> 큐에 쌓인 순서대로 계산되므로, 순차적이고 예측 가능한 상태 관리가 가능합니다.

// [다이어그램 요청: memoizedState와 UpdateQueue 구조 연결도 — 상태 → 업데이트 노드들의 큐 형태]

## 함수형 업데이트와 Automatic Batching

React에서는 상태를 갱신할 때 직접 값을 넣을 수도 있고, 함수형으로 이전 상태를 기준으로 새 값을 만들 수도 있습니다. 특히 여러 번 연속해서 상태를 바꾸는 경우, **함수형 업데이트**가 안전하고 권장됩니다.

```tsx
setCount(prev => prev + 1);
setCount(prev => prev + 1);
```

이 경우, 두 업데이트는 *각각의 이전 상태(prev)*를 기준으로 계산되며, 중간 값이 꼬이지 않습니다.

### Automatic Batching이란?

React 18부터는 여러 개의 상태 업데이트를 하나로 묶어, 렌더링을 **한 번만** 하도록 자동으로 처리해 줍니다. 이를 *Automatic Batching*이라 하며, 퍼포먼스 향상에 매우 중요합니다.

> 이전엔 `setTimeout`이나 `fetch` 같은 비동기 환경에서는 배치가 깨졌지만, React 18에선 대부분 자동으로 묶입니다.

// [다이어그램 요청: 함수형 업데이트와 Batching 처리 흐름 — 큐 안에서 연속 업데이트가 어떻게 순차 처리되는지 시각화]

<Ads/>

## 클래스형 setState와 함수형 setState 비교

클래스 컴포넌트에서도 `this.setState()`를 통해 상태를 관리했지만, 함수형의 `useState`와는 작동 방식이 다릅니다.

| 구분 | 클래스형 setState | 함수형 useState |
|------|--------------------|------------------|
| 병합 방식 | 객체 병합(merge) | 완전 덮어쓰기(replace) |
| 큐 구조 | 객체 기반 큐 | 함수 기반 큐 |
| 상태 단위 | 통합 상태 객체 | 훅 단위의 독립 상태 |

```tsx
// 클래스형 예시
this.setState({ a: 1 });
this.setState({ b: 2 }); // 최종: { a:1, b:2 }

// 함수형 예시
setState({ a: 1 });
setState({ b: 2 }); // 최종: { b:2 }만 유지
```

> 클래스에서는 여러 속성을 병합하지만, 함수형에서는 덮어쓰는 방식이라 실수에 주의해야 합니다.

## 초기 상태의 지연 계산: Lazy Initial State

초기 상태가 복잡한 계산 결과라면 어떻게 할까요? 예를 들어, 무거운 연산 결과를 초기 상태로 써야 할 때 매 렌더링마다 그걸 다시 계산하면 낭비가 큽니다.

```tsx
const [heavy, setHeavy] = useState(() => expensiveCalc());
```

위처럼 *함수를 넣으면 처음 렌더링 시에만 계산*되고, 이후에는 캐싱된 값이 유지됩니다. 이를 *Lazy Initial State*라고 부릅니다.

> 초기화는 렌더링 시점에 딱 한 번만 일어나므로, 성능 최적화에 유리합니다.

// [다이어그램 요청: 일반 초기화 vs lazy 초기화 흐름 비교 — 함수 실행 시점을 시각화]

## 우선순위와 React의 스케줄러

React는 상태 업데이트에 **우선순위**를 부여하여 렌더링을 더 효율적으로 처리합니다.

- 사용자 입력 → 높은 우선순위
- 네트워크 응답 처리 → 중간
- 애니메이션 → 낮음

이 작업을 조율하는 것이 바로 **React Scheduler**이며, 상태 업데이트가 생기면 이 우선순위에 따라 렌더링을 *나중에 밀거나*, *지금 당장 실행*합니다.

> Fiber 아키텍처 덕분에 작업을 나누고 재개하는 것이 가능해진 점, 기억해 주세요.

## 결론

`useState`와 `setState`는 그저 상태를 저장하고 바꾸는 단순한 API가 아닙니다. 내부에는 연결 리스트, 업데이트 큐, 함수형 업데이트, 스케줄러 등 **자료구조적 사고와 알고리즘적 흐름**이 정교하게 녹아 있습니다.

이 원리를 알고 사용하면 성능과 안정성 모두 챙길 수 있는 진짜 React 개발자가 될 수 있습니다. 단순히 코드를 작성하는 것에서 한 걸음 더 나아가, 구조를 이해하며 생각하는 습관을 가져보면 어떨까요?

### 참고
- https://react.dev/reference/react/useState
- https://react.dev/learn/state-a-components-memory
- https://github.com/reactwg/react-18/discussions/21
