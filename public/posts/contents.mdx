---
title_ko: Next.js의 Incremental Static Regeneration(ISR) 완벽 가이드
title_en: Comprehensive Guide to Incremental Static Regeneration (ISR) in Next.js
desc: Next.js의 Incremental Static Regeneration(ISR)에 대한 개념부터 구현 방법, 고급 기능까지 자세히 알아봅니다.
thumbnail_url: /250407-152108.webp
metatag: Next.js, ISR, 데이터 패칭, 정적 사이트 생성, 동적 콘텐츠
---

## 들어가기 전에
웹 개발을 하다 보면, 정적 사이트 생성(SSG)과 서버 사이드 렌더링(SSR)의 장점을 모두 활용하고 싶을 때가 있습니다. Next.js의 Incremental Static Regeneration(ISR)은 이러한 요구를 충족시키는 강력한 기능입니다. 이번 글에서는 ISR의 개념부터 실제 구현 방법, 고급 사용법까지 자세히 알아보겠습니다.

## ISR이란 무엇인가요?

ISR은 Next.js에서 제공하는 기능으로, 이미 생성된 정적 페이지를 특정 시간 간격으로 백그라운드에서 재생성하여 최신 데이터를 반영할 수 있게 합니다. 이를 통해 전체 사이트를 다시 빌드하지 않고도 개별 페이지의 콘텐츠를 업데이트할 수 있습니다. 예를 들어, 블로그 게시물이 추가되었을 때 전체 사이트를 다시 빌드하지 않고도 새로운 게시물이 포함된 페이지를 자동으로 갱신할 수 있습니다.

## ISR의 주요 특징

- *정적 콘텐츠의 부분적 업데이트*: 전체 사이트를 다시 빌드하지 않고도 특정 페이지를 개별적으로 재생성할 수 있습니다.
- *서버 부하 감소*: 미리 생성된 정적 페이지를 제공하므로, 서버 부하를 줄일 수 있습니다.
- *빠른 페이지 로딩*: 정적 페이지를 제공하므로, 사용자에게 빠른 로딩 속도를 제공합니다.
- *대규모 콘텐츠 처리*: 많은 수의 페이지를 효율적으로 관리할 수 있습니다.

## ISR 구현 방법 (Pages 디렉토리 기준)

ISR을 구현하기 위해서는 Next.js의 `getStaticProps` 함수에서 `revalidate` 속성을 설정하면 됩니다. 이 속성은 페이지를 백그라운드에서 재생성하는 주기를 초 단위로 지정합니다.

```typescript
import { GetStaticProps } from 'next'

interface Post {
  id: string
  title: string
  body: string
}

interface Props {
  post: Post
}

export const getStaticProps: GetStaticProps<Props> = async ({ params }) => {
  const post = await fetch(`https://jsonplaceholder.typicode.com/posts/${params?.id}`).then(res => res.json())

  return {
    props: {
      post,
    },
    revalidate: 10, // 10초마다 백그라운드에서 갱신
  }
}
```

이제 위 코드는 해당 게시물 페이지를 10초마다 백그라운드에서 재생성하게 됩니다. 사용자에게는 항상 정적 페이지가 제공되며, 설정된 시간이 지나면 새로운 요청이 들어올 때 자동으로 갱신된 페이지가 제공됩니다.

## App 디렉토리에서 ISR 사용하기

Next.js 13 이후부터는 `app` 디렉토리를 사용하는 새로운 라우팅 방식이 등장했습니다. 여기서 ISR을 적용하는 방식도 다소 다릅니다. `fetch` 함수에 `next` 옵션을 추가하거나, `revalidateTag`, `unstable_cache` 등을 활용할 수 있습니다.

### 기본적인 fetch + revalidate 사용 예시

```tsx
export async function generateStaticParams() {
  const posts = await fetch('https://jsonplaceholder.typicode.com/posts').then(res => res.json())
  return posts.slice(0, 10).map((post: any) => ({ id: post.id.toString() }))
}

export async function getPost(id: string) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`, {
    next: { revalidate: 10 },
  })
  return res.json()
}
```

이 예시에서 `next: { revalidate: 10 }` 옵션을 추가하면, 해당 fetch 요청 결과가 10초마다 갱신되도록 설정됩니다.

### revalidateTag로 특정 리소스만 갱신하기

Next.js는 태그 기반 캐시 무효화 기능도 제공합니다.

```tsx
import { revalidateTag } from 'next/cache'

export async function POST() {
  revalidateTag('posts') // 'posts' 태그를 가진 모든 캐시 무효화
  return new Response('OK')
}
```

### unstable_cache로 캐시 세부 설정

```tsx
import { unstable_cache } from 'next/cache'

const getData = unstable_cache(async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts')
  return res.json()
}, ['posts'], { revalidate: 30 })
```

## 문제 발생 및 해결

- *빌드 시 데이터 누락 문제*: `getStaticProps` 안에서 API 요청 실패 시 페이지 생성이 되지 않는 문제가 있을 수 있습니다. `fallback` 옵션을 `true` 또는 `'blocking'`으로 설정해 이를 방지할 수 있습니다.
- *태그 기반 갱신 시 인증 문제*: `revalidateTag` API를 호출할 때 인증 방식이 필요할 수 있으므로, 백엔드 API 설계에 유의해야 합니다.

## 결론

Next.js의 ISR은 정적 페이지와 동적 콘텐츠의 장점을 동시에 취할 수 있는 매우 유용한 기능입니다. 특히 많은 수의 페이지를 가진 블로그, 커머스, 문서 사이트 등에 적합하며, 최신 데이터를 유연하게 반영할 수 있도록 돕습니다.

## 더 생각해 보기

- `revalidate` 값을 동적으로 설정할 수 있을까?
- 특정 사용자 요청에 따라 페이지를 강제로 리빌드할 수 있을까?
- ISR과 Edge Function은 어떻게 조합할 수 있을까?

이러한 고급 사용법들은 프로젝트에 따라 유용하게 활용될 수 있으며, 다음 글에서 다뤄볼 예정입니다.

## 참고

- [공식 문서: ISR - Next.js Docs](https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration)
- [JSONPlaceholder](https://jsonplaceholder.typicode.com/) - 예제 API

