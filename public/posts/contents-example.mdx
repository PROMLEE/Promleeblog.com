> 이 글은 기본적인 Expo 프로젝트가 생성되어 있다고 가정합니다. Expo 프로젝트를 생성하는 방법은 Expo 프로젝트 생성:[윈도우](/blog/post/117-expo-proj-init), [Mac](/blog/post/143-expo-init-mac)을 참고해주세요.
> 또한 기본적인 React Native CLI 개발 환경에서도 추가 설정만으로 사용 가능합니다.

> [WalletKit 세션 연결하기 (React Native, Reown)](/blog/post/159-rn-walletkit-session-proposal) 포스팅에서 이어지는 내용입니다.

https://reactnative.dev/img/header_logo.svg
https://cdn.worldvectorlogo.com/logos/expo-go-app.svg
https://upload.wikimedia.org/wikipedia/commons/8/8e/Nextjs-logo.svg


---
title_ko: React SSR 완벽 가이드 - 개념부터 스트리밍, Hydration, 서버 컴포넌트까지
title_en: React SSR Complete Guide - From Concept to Streaming, Hydration, and Server Components
desc: React SSR(Server-Side Rendering)의 개념, 필요성, renderToPipeableStream, Suspense, Hydration, 서버 컴포넌트, 캐싱 전략까지 모든 내용을 총정리한 완벽 가이드입니다.
thumbnail_url: /react-ssr-complete.webp
metatag: React, SSR, 서버 사이드 렌더링, 웹 성능, React 18, renderToPipeableStream, Suspense, hydration, 서버 컴포넌트, 캐싱 전략, Next.js
---
## 들어가기 전에
React 애플리케이션을 만들다 보면 "이걸 서버에서 렌더링할 수는 없을까?"라는 생각을 한 번쯤은 하게 됩니다. 특히 검색엔진 최적화(SEO), 첫 로딩 속도, 소셜 미디어 미리보기 등을 고려하다 보면 클라이언트에서만 렌더링하는 방식으로는 부족함을 느끼게 됩니다.
이럴 때 우리가 사용할 수 있는 기법 중 하나가 바로 SSR, 즉 *Server-Side Rendering*입니다. 이번 포스트에서는 SSR에 대해 깊이 있게 다루며, React 개발자 입장에서 SSR이 어떻게 동작하는지, 언제 사용하면 좋은지, 어떤 한계가 있는지를 단계별로 알아보겠습니다.

## SSR이란 무엇인가요?
SSR은 Server-Side Rendering의 줄임말로, *브라우저가 아닌 서버에서 HTML을 생성해서 보내주는 방식*입니다. React 같은 SPA(Single Page Application)는 보통 클라이언트에서 JavaScript가 실행된 이후에야 콘텐츠가 나타나지만, SSR을 사용하면 서버에서 미리 HTML을 렌더링해서 클라이언트에게 전달할 수 있습니다.
이렇게 하면 사용자는 화면을 더 빨리 볼 수 있고, 검색 엔진도 HTML을 바로 읽을 수 있어 SEO에도 유리합니다.
### 클라이언트 렌더링과 비교해볼까요?
#### 클라이언트 렌더링:
1. 브라우저가 HTML 파일을 다운로드합니다.
2. HTML 안에 있는 JS 번들(script)을 불러옵니다.
3. JS가 실행되어 React 컴포넌트를 렌더링합니다.
4. 화면이 표시됩니다.
#### SSR:
1. 사용자가 페이지에 접속하면 서버가 React 컴포넌트를 렌더링합니다.
2. 렌더링된 HTML을 클라이언트에 전달합니다.
3. 브라우저가 HTML을 받아 화면을 곧바로 보여줍니다.
4. 이후 React의 hydrate 함수가 동작하여 클라이언트에서 인터랙티브한 앱으로 변환됩니다.
SSR은 사용자에게 *빠르게 보이는 화면*을 제공하고, 클라이언트에서는 그 후에 자바스크립트를 통해 앱을 완성시키는 방식입니다.

## SSR이 왜 필요할까요?
SSR은 다음과 같은 경우에 유용하게 사용됩니다:
- **SEO가 중요한 페이지**: 검색 엔진은 JavaScript를 완벽히 실행하지 못하는 경우가 있기 때문에, HTML 형태로 콘텐츠를 제공하는 SSR이 유리합니다.
- **초기 로딩 속도가 중요한 서비스**: 서버에서 미리 렌더링된 HTML을 보내기 때문에 첫 화면이 더 빨리 보입니다.
- **소셜 미디어 공유**: 페이스북이나 트위터 같은 서비스는 링크를 공유할 때 HTML의 메타 태그를 기준으로 미리보기를 생성하는데, SSR을 사용하면 이 정보도 정확히 전달할 수 있습니다.

## SSR의 기본 동작 흐름
SSR의 동작 과정을 조금 더 구체적으로 살펴보겠습니다:
1. 사용자가 웹사이트에 접속합니다.
2. 서버는 사용자의 요청을 처리합니다.
3. 서버에서 React 컴포넌트를 renderToString 혹은 renderToPipeableStream 등을 사용하여 HTML로 변환합니다.
4. 변환된 HTML을 사용자에게 전송합니다.
5. 브라우저는 이 HTML을 바로 렌더링하여 화면을 표시합니다.
6. JavaScript가 다운로드되고, React의 hydrate 함수가 실행되어 앱이 인터랙티브하게 동작하기 시작합니다.

## React 18에서 달라진 점 - 스트리밍 SSR
React 18에서는 전체 HTML을 완성한 후에 보내던 방식에서 벗어나, *부분적으로 렌더링된 HTML을 스트리밍 방식으로 전달*하는 기능이 추가되었습니다. 이로 인해 사용자에게 더 빠른 응답을 제공할 수 있게 되었습니다.
### renderToPipeableStream이란?
React 18에서 새롭게 도입된 SSR 함수인 `renderToPipeableStream`은 *준비된 HTML부터 조금씩 먼저 보내주고, 아직 준비 안 된 부분은 나중에 채워주는 방식*으로 SSR을 수행합니다.
```ts
import express from 'express';
import React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import App from './App';
const app = express();
app.get('*', (req, res) => {
  const { pipe } = renderToPipeableStream(<App />, {
    onShellReady() {
      res.setHeader('Content-Type', 'text/html');
      pipe(res);
    },
    onError(err) {
      console.error(err);
    }
  });
});
```
### Suspense와의 연동
React 18의 스트리밍 SSR은 `Suspense` 컴포넌트와 매우 잘 통합됩니다. 예를 들어 다음과 같은 구조를 생각해봅시다:
```tsx
function App() {
  return (
    <div>
      <Header />
      <Suspense fallback={<div>Loading content...</div>}>
        <MainContent />
      </Suspense>
      <Footer />
    </div>
  );
}
```
`Header`와 `Footer`는 바로 렌더링되지만, `MainContent`는 데이터를 불러오는 데 시간이 걸리는 경우입니다. 이때 Header와 Footer는 먼저 보여지고, MainContent는 나중에 채워지는 방식으로 SSR이 진행됩니다.

## Hydration이란?
Hydration은 SSR의 마지막 단계로, 서버에서 전달된 정적인 HTML에 *React의 동적인 기능을 부여하는 과정*입니다. 클라이언트는 이 HTML을 받아서 React로 다시 구성한 Virtual DOM과 비교하고, 이벤트 처리와 상태 관리를 활성화합니다.
### 주의사항
Hydration 과정에서 서버와 클라이언트의 출력이 다르면 *hydration mismatch* 오류가 발생할 수 있으므로 매우 신중한 렌더링이 필요합니다.

## 서버 컴포넌트(Server Components)
React에서 도입된 서버 컴포넌트는 *오직 서버에서만 실행되며 클라이언트에 번들되지 않는 컴포넌트*입니다. 이를 통해 보안이 필요한 로직을 숨기고 번들 크기를 줄일 수 있습니다.
```tsx
// app/page.tsx
import PostList from './PostList';
export default function Home() {
  return (
    <main>
      <h1>블로그</h1>
      <PostList />
    </main>
  );
}
// app/PostList.tsx
export default async function PostList() {
  const posts = await fetchPosts();
  return (
    <ul>
      {posts.map(p => <li key={p.id}>{p.title}</li>)}
    </ul>
  );
}
```
이 구조에서는 `PostList`가 서버에서 실행되어 HTML로 렌더링되고, 클라이언트에는 자바스크립트 번들이 전달되지 않습니다.

## SSR에서의 캐싱 전략
SSR은 서버 리소스를 사용하기 때문에 효율적인 *캐싱 전략*이 중요합니다.
### 대표적인 캐싱 방식
1. **Full-page Caching**: 전체 HTML을 CDN 등에 저장
2. **Component-level Caching**: Redis, 메모리 등을 이용해 컴포넌트 출력이나 API 응답을 캐싱
3. **ISR (Incremental Static Regeneration)**: Next.js에서 특정 시간마다 HTML을 백그라운드에서 갱신

## 결론
이 포스트에서는 SSR의 개념, 필요성부터 시작해서 React 18의 스트리밍 SSR, Hydration, 서버 컴포넌트, 캐싱 전략까지 모든 내용을 다루었습니다.
이제 SSR을 언제, 왜 사용하는지에 대해 명확히 이해하셨을 것입니다. 각 기술의 특징을 파악하고, 상황에 맞게 선택하여 적용하신다면 성능과 SEO, 사용자 경험까지 향상된 React 애플리케이션을 만들 수 있습니다.
### 참고
- [DeveloperWay: SSR deep dive for React developers](https://www.developerway.com/posts/ssr-deep-dive-for-react-developers)
- [React 공식 문서: renderToPipeableStream](https://react.dev/reference/react-dom/server/renderToPipeableStream)
- [Next.js Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components)
- [React hydration](https://react.dev/reference/react-dom/client/hydrateRoot)